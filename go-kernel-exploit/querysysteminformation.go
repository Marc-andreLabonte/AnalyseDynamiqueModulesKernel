package main

import (
	"fmt"
    //s"
	"syscall"
	"unsafe"
	"bytes"
	"encoding/binary"
	//"golang.org/x/sys/windows"
	//"github.com/shirou/gopsutil/v3/internal/common"
	
)

// voir https://forum.golangbridge.org/t/using-syscall-syscalln-as-replacement-for-syscall-syscall/27895
// voir https://zchee.github.io/golang-wiki/WindowsDLLs/
// https://github.com/shirou/gopsutil
var (
	//ntdll, _        = syscall.LoadLibrary("ntdll.dll")
	//sysinfoHandle, _ = syscall.GetProcAddress(ntdll, "NtQuerySystemInformation")
	pLazyDll *syscall.LazyDLL = syscall.NewLazyDLL("ntdll.dll")
	pLazyProc *syscall.LazyProc = pLazyDll.NewProc("NtQuerySystemInformation")

)

// voir https://undocumented.ntinternals.net/
type SYSTEM_INFORMATION_CLASS uint64

const (

    SystemBasicInformation SYSTEM_INFORMATION_CLASS = iota
    SystemProcessorInformation
    SystemPerformanceInformation
    SystemTimeOfDayInformation
    SystemPathInformation
    SystemProcessInformation
    SystemCallCountInformation
    SystemDeviceInformation
    SystemProcessorPerformanceInformation
    SystemFlagsInformation
    SystemCallTimeInformation
    SystemModuleInformation
    SystemLocksInformation
    SystemStackTraceInformation
    SystemPagedPoolInformation
    SystemNonPagedPoolInformation
    SystemHandleInformation
    SystemObjectInformation
    SystemPageFileInformation
    SystemVdmInstemulInformation
    SystemVdmBopInformation
    SystemFileCacheInformation
    SystemPoolTagInformation
    SystemInterruptInformation
    SystemDpcBehaviorInformation
    SystemFullMemoryInformation
    SystemLoadGdiDriverInformation
    SystemUnloadGdiDriverInformation
    SystemTimeAdjustmentInformation
    SystemSummaryMemoryInformation
    SystemNextEventIdInformation
    SystemEventIdsInformation
    SystemCrashDumpInformation
    SystemExceptionInformation
    SystemCrashDumpStateInformation
    SystemKernelDebuggerInformation
    SystemContextSwitchInformation
    SystemRegistryQuotaInformation
    SystemExtendServiceTableInformation
    SystemPrioritySeperation
    SystemPlugPlayBusInformation
    SystemDockInformation
    SystemPowerInformation
    SystemProcessorSpeedInformation
    SystemCurrentTimeZoneInformation
    SystemLookasideInformation
)

type SYSTEM_MODULE struct  {
	Reserved1 uint64  
	Reserved2 uint64
	ImageBase uint64
	ImageSize uint32
	Flags uint32
	Index uint16
	NameLength uint16
	LoadCount uint16
	PathLength uint16
	ImageName [256]byte
}

type SYSTEM_MODULE_INFORMATION struct  {
	ModulesCount uint64
	Modules [1]SYSTEM_MODULE
}

func GetPsInitialSystemProc(lpNtoskrnlBase uint64) uint64 {
	p := fmt.Println
	p(fmt.Sprintf("Kernel base is at: %x\n", lpNtoskrnlBase))
	var pDll *syscall.LazyDLL = syscall.NewLazyDLL("ntoskrnl.exe")
	var pProc *syscall.LazyProc = pDll.NewProc("PsInitialSystemProcess")

	var ntos uint64 = uint64(pDll.Handle())
	p(fmt.Sprintf("Handle to module ntoskrnl.exe at: %x\n", pDll.Handle()))
	
	var initial_proc uint64 = uint64(pProc.Addr())
	p(fmt.Sprintf("Address of PsInitialSystemProcess: %x\n", initial_proc))
	return  uint64((initial_proc - ntos) + lpNtoskrnlBase)
}



func NtQuerySystemInformation() uint64 {
	//defer syscall.FreeLibrary(ntdll)

	lpHeapBuffer := make([]byte, 0x20000)
	p := fmt.Println
	//var _SystemModuleInformation uintptr = uintptr(SystemModuleInformation)
	var dwBytesReturned uint32
	var psm SYSTEM_MODULE_INFORMATION
	//var nargs uintptr = 4
	//var tries int
	
	
	// try shirou/gopsutil way
	//NtStatus := NtQuerySystemInformation(uint32((SystemModuleInformation), &lpHeapBuffer[0], uint32(0x2000), &dwBytesReturned)
	_, _, _ = syscall.SyscallN(pLazyProc.Addr(),
		uintptr(SystemModuleInformation),
		uintptr(unsafe.Pointer(&lpHeapBuffer[0])),
		uintptr(0x20000),
		uintptr(unsafe.Pointer(&dwBytesReturned)))
	var modulesbuf = bytes.NewBuffer(lpHeapBuffer[0:dwBytesReturned])
	//myStruct := MyStruct{}
  
	//dec := gob.NewDecoder(modulesbuf)
	if dwBytesReturned > 0 {
		
		err := binary.Read(modulesbuf, binary.LittleEndian, &psm)
		if err != nil {
			fmt.Println("decode error:", err)
			
		}
		
	}
	
	var SystemProc uint64  = GetPsInitialSystemProc(psm.Modules[0].ImageBase)
	
	p(fmt.Sprintf("Found initial system process at %x\n", SystemProc))


	return SystemProc

}